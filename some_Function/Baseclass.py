import os
from PyQt5 import  QtWidgets
from PyQt5.QtWidgets import  QFileDialog
from matplotlib.figure import Figure
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from PyQt5.QtGui import QKeySequence
from PyQt5.QtWidgets import QShortcut
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow
from layers import data_for_single_gui
import javabin
import numpy as np
from PyQt5.QtWidgets import QWidget,QApplication
import drawtools
import time
from matplotlib.ticker import  MultipleLocator
# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Baseclass.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.widgets import Cursor
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtGui import QKeySequence
from layers import draw_information_line_topo
import os
import GUI_Function_Part

class PlotCanvas(FigureCanvas):
    def __init__(self, parent=None, width=15, height=15, dpi=50):
        fig = Figure(figsize=(width, height), dpi=dpi)
        FigureCanvas.__init__(self, fig)
        self.setParent(parent)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(2)
        sizePolicy.setVerticalStretch(2)
        sizePolicy.setHeightForWidth(True)
        FigureCanvas.setSizePolicy(self, sizePolicy)
        FigureCanvas.updateGeometry(self)
        self.setMinimumSize(QtCore.QSize(1000,1000))
        self.setMaximumSize(QtCore.QSize(1800, 1800))


class Ui_Form(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)
        #self.layer_all_information = data_for_single_gui()
        self.setObjectName('Baseui')
        self.resize(800, 800)
        self.centralWidget = QtWidgets.QWidget(self)
        self.centralWidget.setObjectName('centerwidget')
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.centralWidget)
        self.horizontalLayout.setObjectName("horizontalLayout")


        self.canvas = PlotCanvas()

        self.ax = self.canvas.figure.add_subplot(111)

        self.canvas.draw()

        #self.layer_all_information = data_for_single_gui()

        self.horizontalLayout.addWidget(self.canvas)
        self.setCentralWidget(self.centralWidget)

        self.shortcut_contrast_ration = QShortcut(QKeySequence('F11'),self.centralWidget,self.constrastratio)
        self.shortcut_add_color = QShortcut(QKeySequence('F3'),self.centralWidget,self.changecolor)
        self.shortcut_decrease_color = QShortcut(QKeySequence('F2'), self.centralWidget, self.changecolor_1)
        self.shortcut_open_bin_file = QShortcut(QKeySequence('Ctrl+J'),self.centralWidget,self.openbinfile)
        self.shortcut_draw_tools = QShortcut(QKeySequence('F10'),self.centralWidget,self.drawtools)
        self.shortcut_fourier_transform = QShortcut(QKeySequence('Ctrl+F'),self.centralWidget,self.fouriertransform)
        self.shortcut_fit_figure = QShortcut(QKeySequence('Ctrl+F'),self.centralWidget,self.fitfigure)
        self.shortclipboard = QShortcut(QKeySequence('Ctrl+C'),self.centralWidget,self.to_clipboard)


    def fitfigure(self):
        """
        fit的种类，有必要增加一下，增加fit：
        linefit,
        planefit，
        我现在知道的fit有 subtract_line_fit(V&H), subtract_plane_fit,
        subtract_polynomial background(Vertical&Horizontal&Plane),
        normalize((0,1),(-1,1)以及其他的。
        supress bad pixel。
        invert data(数值反演)
        在这里，我认为处理后最好还是弹出对话框设置当前layer的名字，麻烦是麻烦了点。
        :return:
        """
        pass
    def fouriertransform(self):
        """
        Fourier Transform的过程中，我希望引入一个功能，可以计算倒格矢量，倒格矢的计算不再是单纯的2pi/lambda,这个过程中，我要创造新的layer,并添加进入
        all_layer这样的信息里面。考虑的格子，我希望更为复杂或者说是更为周密一些。这个过程中我们应该引入备选框，设定我们预期的倒格矢的倍数关系。
        有以下几种情况:正交/四方/三角/Honeycomb/kagome，此外我认为我们应该对fft的显示给出优化，log显示、正态显示等等。都是我们值得注意的
        :return:
        """
        cmap,current_layer_name,current_layer,draw_index,vmins,vmaxs = self.layer_all_information.return_all_draw_index()
    def to_clipboard(self):
        """
        将图片复制到剪贴板上
        :return:
        """
        QApplication.clipboard().setImage(QWidget.grab(self.canvas).toImage())

    def drawtools(self):
        self.windows_drawtools = drawtools.draw_interface(self.layer_all_information.return_current_layer_value())
        self.windows_drawtools.return_all_info.connect(self.changedrawtools)
        self.windows_drawtools.show()
    def changedrawtools(self,draw_index:draw_information_line_topo):
        self.layer_all_information.refresh_draw_index(draw_index)
        self.topomapdraw()
    #def draw_function(self):
    def constrastratio(self):
        self.windows_contrastration = GUI_Function_Part.Ui_Form_contrast()
        self.windows_contrastration.slider_emit.connect(self.sliderfunction)
        self.windows_contrastration.show()
    def sliderfunction(self,number1,number2):
        """
        :param number1:
        :param number2:
        :return:
        slider function
        """
        time_1 = time.time()

        vmins = number1/2
        vmaxs = number2/2
        self.layer_all_information.change_contrast_ratio(vmins,vmaxs)
        self.draw_quickly()
        time_2 = time.time()
        print("一共耗时"+str(time_2-time_1)+'秒')

    def openbinfile(self):
        self.filename,_ =QFileDialog.getOpenFileName(self.centralWidget,'open bin file',r'F:\CsV3Sb5','binfile(*.bin)')
        filefolder, basename = os.path.split(self.filename)
        filename,extension = os.path.splitext(self.filename)
        layers = javabin.read_java_bin_single_layer(self.filename)
        self.layer_all_information = data_for_single_gui(filename,layers=layers)
        self.layer_all_information.change_filepath(filefolder)
        #self.layer_all_information.append_layer(filename,layers)
        #self.layer_all_information.change_filepath(filefolder)
        self.topomapdraw()

    def changecolor(self):
        time_1 = time.time()
        self.layer_all_information.change_color(1)
        self.draw_quickly()
        time_2 = time.time()
        print("一共耗时"+str(time_2-time_1)+'秒')

    def changecolor_1(self):
        time_1 = time.time()

        self.layer_all_information.change_color(-1)
        self.draw_quickly()
        time_2 = time.time()
        print("一共耗时"+str(time_2-time_1)+'秒')
    def draw_quickly(self):
        cmap,current_layer_name,current_layer,draw_index,vmins,vmaxs = self.layer_all_information.return_all_draw_index()
        self.background = self.canvas.copy_from_bbox(self.ax.bbox)
        #xx,yy = np.meshgrid(current_layer.new_x,current_layer.new_y)
        vminss = np.percentile(current_layer.data,vmins)
        vmaxss = np.percentile(current_layer.data, vmaxs)
        #self.ax.pcolormesh(xx,yy,current_layer.data,vmin=vminss,vmax=vmaxss,cmap=cmap,)
        self.canvas.restore_region(self.background)
        #self.figures.set_array(current_layer.data)
        self.figures.set_clim(vmin=vminss,vmax=vmaxss)
        self.figures.set_cmap(cmap=cmap)

        self.canvas.blit(self.ax.bbox)
        self.canvas.draw()
    def topomapdraw(self):
        """
        目前来说渲染的时间有点长了，正在寻找方法优化
        :param 绘图函数 CutFigure/laplace/others
        :return:
        需要将这一层作为额外的输入函数吗？
        这里直接调用return draw_index吧
        """
        cmap,current_layer_name,current_layer,draw_index,vmins,vmaxs = self.layer_all_information.return_all_draw_index()
        font = {'family':draw_index.title['font'],'weight':'normal','size':draw_index.title['size']}
        labels = ['Bottom','Top','Right','Left']
        major_minor = ['Major','Minor']
        scale_list = {}
        label_major_minor_all = ['Majorticks','Minorticks']
        for label_direction in draw_index.scale.keys():
            for label_major_minor in label_major_minor_all:
                if draw_index.scale[label_direction][label_major_minor]['style'] == 'By Increment':
                    scale_list[label_direction+'_'+label_major_minor] = MultipleLocator(draw_index.scale[label_direction][label_major_minor]['value'])
                elif draw_index.scale[label_direction][label_major_minor]['style'] == 'By Counts':
                    scale_list[label_direction+'_'+label_major_minor] = MultipleLocator((draw_index.scale[label_direction]['Range']['maxus']-draw_index.scale[label_direction]['Range']['minus']
                                                                                         )/(draw_index.scale[label_direction][label_major_minor]['value']))
        self.ax.xaxis.set_major_locator(scale_list['Horizontal'+'_'+label_major_minor_all[0]])
        self.ax.xaxis.set_minor_locator(scale_list['Horizontal'+ '_'+label_major_minor_all[1]])
        self.ax.yaxis.set_major_locator(scale_list['Vertical'+'_'+label_major_minor_all[0]])
        self.ax.yaxis.set_minor_locator(scale_list['Vertical'+ '_'+label_major_minor_all[1]])

        for label in labels:
            self.ax.spines[label.lower()].set_linewidth(draw_index.line_and_ticks[label]['Linewidth'])
            for index in major_minor:
                if label == 'Bottom':
                    if index == 'Major':
                        self.ax.tick_params(axis='x',which=index.lower(),direction=draw_index.line_and_ticks[label][index+'Ticks']['style'],
                                        length = draw_index.line_and_ticks[label][index+'Ticks']['length'],
                                        width = draw_index.line_and_ticks[label][index+'Ticks']['thickness'],
                                        labelsize =draw_index.line_and_ticks[label][index+'Ticks']['fontsize'],
                                        bottom=True)
                    else:
                        self.ax.tick_params(axis='x', which=index.lower(),
                                            direction=draw_index.line_and_ticks[label][index + 'Ticks']['style'],
                                            length=draw_index.line_and_ticks[label][index + 'Ticks']['length'],
                                            width=draw_index.line_and_ticks[label][index + 'Ticks']['thickness'],
                                            bottom=True)

                elif label == 'Top':
                    self.ax.tick_params(axis='x',which=index.lower(),direction=draw_index.line_and_ticks[label][index+'Ticks']['style'],
                                        length = draw_index.line_and_ticks[label][index+'Ticks']['length'],
                                        width = draw_index.line_and_ticks[label][index+'Ticks']['thickness'],top=True)
                elif label == 'Right':
                    self.ax.tick_params(axis='y', which=index.lower(),
                                        direction=draw_index.line_and_ticks[label][index + 'Ticks']['style'],
                                        length=draw_index.line_and_ticks[label][index + 'Ticks']['length'],
                                        width=draw_index.line_and_ticks[label][index + 'Ticks']['thickness'], right=True)
                elif label == 'Left':
                    if index =='Major':
                        self.ax.tick_params(axis='y', which=index.lower(),
                                        direction=draw_index.line_and_ticks[label][index + 'Ticks']['style'],
                                        length=draw_index.line_and_ticks[label][index + 'Ticks']['length'],
                                        width=draw_index.line_and_ticks[label][index + 'Ticks']['thickness'],
                                        labelsize=draw_index.line_and_ticks[label][index+'Ticks']['fontsize'],
                                        left=True)
                    else:
                        self.ax.tick_params(axis='y', which=index.lower(),
                                            direction=draw_index.line_and_ticks[label][index + 'Ticks']['style'],
                                            length=draw_index.line_and_ticks[label][index + 'Ticks']['length'],
                                            width=draw_index.line_and_ticks[label][index + 'Ticks']['thickness'],
                                            left=True)

        all_ticks = self.ax.get_xticklabels()+self.ax.get_yticklabels()
        [ticks.set_fontname(font['family'])for ticks in all_ticks]
        #self.ax.get_xticklabels().set_fontsize(draw_index.line_and_ticks['Bottom']['MajorTicks']['fontsize'])
        #self.ax.get_yticklabels().set_fontsize(draw_index.line_and_ticks['Left']['MajorTicks']['fontsize'])
        #if draw_index.line_and_ticks.
        #[ticks.set_fontsize(draw_index.line_and_ticks['Left']['MajorTicks']['fontsize']) for ticks in all_ticks]
        self.ax.axis(draw_index.show_axis)
        xx,yy = np.meshgrid(current_layer.new_x,current_layer.new_y)
        self.ax.set_xlabel(draw_index.title['xlabel'],font)
        self.ax.set_ylabel(draw_index.title['ylabel'],font)
        vminss = np.percentile(current_layer.data,vmins)
        vmaxss = np.percentile(current_layer.data, vmaxs)
        self.ax.set_box_aspect(1)#可以让我们的ax始终保存比例为1
        self.figures = self.ax.pcolormesh(xx,yy,current_layer.data,vmin=vminss,vmax=vmaxss,cmap=cmap,shading='flat')
        self.canvas.draw()
    def resizeEvent(self, a0: QtGui.QResizeEvent):
        """
        重写了尺寸拉伸函数，可以确保窗口拉伸过程中纵横比不变
        :param a0:
        :return:
        """
        if a0.size().height()>a0.size().width():
            self.resize(a0.size().width(),a0.size().width())
        else:
            self.resize(a0.size().height(),a0.size().height())

if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_Form()
    ui.show()
    sys.exit(app.exec_())
